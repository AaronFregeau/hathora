import module from "module";
import dependencyTree from "dependency-tree";
import chokidar from "chokidar";
import seedrandom from "seedrandom";
import { decode, decodeMulti, encode } from "@msgpack/msgpack";
import { onNewUserState } from "./proxy";
import { Context } from "./methods";
import { UserData, {{makeRequestName initialize}} } from "./types";

const deps = dependencyTree.toList({
  directory: ".",
  filename: module.createRequire(import.meta.url).resolve("../impl"),
  filter: (path) => !path.includes(".rtag") && !path.includes("node_modules"),
});
let impl = new (await import("../impl")).Impl();
chokidar.watch(deps).on("change", async () => {
  impl = new (await import(`../impl.ts#${Math.random()}`)).Impl();
});

type StateId = string;
type State = ReturnType<typeof impl.{{initialize}}>;
interface UpdateRequest {
  method: string;
  msgId: string;
  args: any;
}

const states: Map<StateId, State & { _rng: ReturnType<seedrandom> }> = new Map();
const changedStates: Set<StateId> = new Set();
const userResponses: Map<StateId, Map<string, Record<string, {{error.typeString}} | null>>> = new Map();
const subscriptions: Map<StateId, Set<UserData>> = new Map();

export default class Store {
  constructor() {
    setInterval(() => {
      changedStates.forEach((stateId) => {
        const responses = userResponses.get(stateId);
        subscriptions.get(stateId)!.forEach((user) => {
          sendUpdate(stateId, user, responses?.get(user.id) ?? {});
        });
        userResponses.delete(stateId);
      });
      userResponses.forEach((responses, stateId) => {
        subscriptions.get(stateId)!.forEach((user) => {
          if (responses.has(user.id)) {
            sendUpdate(stateId, user, responses.get(user.id)!);
          }
        });
      });
      changedStates.clear();
      userResponses.clear();
    }, 100);
    {{#if tick}}

    let prevUpdateTime = Date.now();
    setInterval(() => {
      const currTime = Date.now();
      states.forEach((state, stateId) => {
        const result = impl.onTick(state, ctx(state._rng, currTime), (currTime - prevUpdateTime) / 1000);
        if (result.type === "modified") {
          changedStates.add(stateId);
        }
      });
      prevUpdateTime = currTime;
    }, 50);
    {{/if}}
  }
  newState(stateId: StateId, user: UserData, data: Buffer) {
    const args = decodeMulti(data).next().value as {{makeRequestName initialize}};
    const seed = Math.random().toString();
    const rng = seedrandom(seed);
    const time = Date.now();
    const state = impl.{{initialize}}(user, ctx(rng, time), args);
    states.set(stateId, Object.assign(state, { _rng: rng }));
  }
  handleUpdate(stateId: StateId, user: UserData, data: Buffer) {
    const state = states.get(stateId);
    if (state === undefined) {
      return;
    }
    const { method, args, msgId } = decode(data) as UpdateRequest;
    const time = Date.now();
    const result = getResult(state, user, method, ctx(state._rng, time), args);
    if (result !== undefined) {
      if (result.type === "modified") {
        changedStates.add(stateId);
      }
      const response = result.type === "modified" ? null : result.error ?? null;
      if (!userResponses.has(stateId)) {
        userResponses.set(stateId, new Map([[user.id, { [msgId]: response }]]));
      } else {
        if (!userResponses.get(stateId)!.has(user.id)) {
          userResponses.get(stateId)!.set(user.id, { [msgId]: response });
        } else {
          userResponses.get(stateId)!.get(user.id)![msgId] = response;
        }
      }
    }
  }
  subscribeUser(stateId: StateId, user: UserData) {
    if (states.has(stateId)) {
      if (!subscriptions.has(stateId)) {
        subscriptions.set(stateId, new Set([user]));
      } else {
        subscriptions.get(stateId)!.add(user);
      }
      sendUpdate(stateId, user, {});
    }
  }
  unsubscribeUser(stateId: StateId, user: UserData) {
    if (states.has(stateId)) {
      const users = subscriptions.get(stateId)!;
      if (users.size > 1) {
        users.delete(user);
      } else {
        subscriptions.delete(stateId);
      }
    }
  }
}

function getResult(state: State, user: UserData, method: string, ctx: Context, args: any) {
  switch (method) {
    {{#each methods}}
    {{#if (ne @key ../initialize)}}
    case "{{@key}}":
      return impl.{{@key}}(state, user, ctx, args);
    {{/if}}
    {{/each}}
    default:
      return undefined;
  }
}

function sendUpdate(stateId: StateId, user: UserData, responses: Record<string, string | null>) {
  const state = impl.getUserState(states.get(stateId)!, user);
  return onNewUserState(stateId, user, encode({ state, responses }, { ignoreUndefined: true }));
}

function ctx(rng: ReturnType<seedrandom>, time: number) {
  return {
    rand: () => rng(),
    randInt: (limit?: number) => (limit === undefined ? rng.int32() : Math.floor(rng() * limit)),
    time: () => time,
  };
}
