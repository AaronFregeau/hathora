import * as utf8 from "utf8-buffer";
import utf8Size from "utf8-buffer-size";
const { pack, unpack } = (utf8 as any).default ?? utf8;

export class BitString {
  public bytes: number[] = [0];
  private pos = 0;

  public push(val: 0 | 1) {
    if (this.pos === 7) {
      this.bytes.push(0x80);
      this.pos = 0;
    }
    this.bytes[this.bytes.length - 1] |= val << this.pos;
    this.pos++;
  }

  public pop() {
    const bytesIdx = Math.floor(this.pos / 7);
    const bit = ((this.bytes[bytesIdx] >> this.pos % 7) & 1) as 0 | 1;
    this.pos++;
    return bit;
  }
}

export class Writer {
  private pos = 0;
  private view = new DataView(new ArrayBuffer(64));
  private bytes = new Uint8Array(this.view.buffer);

  public writeUInt8(val: number) {
    this.ensureSize(1);
    this.view.setUint8(this.pos, val);
    this.pos += 1;
  }

  public writeUInt32(val: number) {
    this.ensureSize(4);
    this.view.setUint32(this.pos, val);
    this.pos += 4;
  }

  public writeUVarint(val: number) {
    if (val < 0x80) {
      this.ensureSize(1);
      this.view.setUint8(this.pos, val);
      this.pos += 1;
    } else if (val < 0x4000) {
      this.ensureSize(2);
      this.view.setUint16(this.pos, (val & 0x7f) | ((val & 0x3f80) << 1) | 0x8000);
      this.pos += 2;
    } else if (val < 0x200000) {
      this.ensureSize(3);
      this.view.setUint8(this.pos, (val >> 14) | 0x80);
      this.view.setUint16(this.pos + 1, (val & 0x7f) | ((val & 0x3f80) << 1) | 0x8000);
      this.pos += 3;
    } else if (val < 0x10000000) {
      this.ensureSize(4);
      this.view.setUint32(
        this.pos,
        (val & 0x7f) | ((val & 0x3f80) << 1) | ((val & 0x1fc000) << 2) | ((val & 0xfe00000) << 3) | 0x80808000
      );
      this.pos += 4;
    } else if (val < 0x800000000) {
      this.ensureSize(5);
      this.view.setUint8(this.pos, Math.floor(val / Math.pow(2, 28)) | 0x80);
      this.view.setUint32(
        this.pos + 1,
        (val & 0x7f) | ((val & 0x3f80) << 1) | ((val & 0x1fc000) << 2) | ((val & 0xfe00000) << 3) | 0x80808000
      );
      this.pos += 5;
    } else if (val < 0x40000000000) {
      this.ensureSize(6);
      const shiftedVal = Math.floor(val / Math.pow(2, 28));
      this.view.setUint16(this.pos, (shiftedVal & 0x7f) | ((shiftedVal & 0x3f80) << 1) | 0x8080);
      this.view.setUint32(
        this.pos + 2,
        (val & 0x7f) | ((val & 0x3f80) << 1) | ((val & 0x1fc000) << 2) | ((val & 0xfe00000) << 3) | 0x80808000
      );
      this.pos += 6;
    } else {
      throw new Error("Value out of range");
    }
  }

  public writeVarint(val: number) {
    const bigval = BigInt(val);
    this.writeUVarint(Number((bigval >> 63n) ^ (bigval << 1n)));
  }

  public writeFloat(val: number) {
    this.ensureSize(4);
    this.view.setFloat32(this.pos, val, true);
    this.pos += 4;
  }

  public writeBitString(bitstring: BitString) {
    while (bitstring.bytes[bitstring.bytes.length - 1] === 0x80) {
      bitstring.bytes.pop();
    }
    this.writeBuffer(new Uint8Array(bitstring.bytes.reverse()));
  }

  public writeString(val: string) {
    if (val.length > 0) {
      const byteSize = utf8Size(val);
      this.writeUVarint(byteSize);
      this.ensureSize(byteSize);
      pack(val, this.bytes, this.pos);
      this.pos += byteSize;
    } else {
      this.writeUInt8(0);
    }
  }

  public writeBuffer(buf: Uint8Array) {
    this.ensureSize(buf.length);
    this.bytes.set(buf, this.pos);
    this.pos += buf.length;
  }

  public toBuffer() {
    return this.bytes.subarray(0, this.pos);
  }

  private ensureSize(size: number) {
    while (this.view.byteLength < this.pos + size) {
      const newView = new DataView(new ArrayBuffer(this.view.byteLength * 2));
      const newBytes = new Uint8Array(newView.buffer);
      newBytes.set(this.bytes);
      this.view = newView;
      this.bytes = newBytes;
    }
  }
}

export class Reader {
  private pos = 0;
  private view: DataView;
  private bytes;

  public constructor(buf: ArrayBufferView) {
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.bytes = new Uint8Array(this.view.buffer, buf.byteOffset, buf.byteLength);
  }

  public readUInt8() {
    const val = this.view.getUint8(this.pos);
    this.pos += 1;
    return val;
  }

  public readUInt32() {
    const val = this.view.getUint32(this.pos);
    this.pos += 4;
    return val;
  }

  public readUVarint() {
    let val = 0;
    while (true) {
      let byte = this.view.getUint8(this.pos++);
      if (byte < 0x80) {
        return val + byte;
      }
      val = (val + (byte & 0x7f)) * 128;
    }
  }

  public readVarint() {
    const val = BigInt(this.readUVarint());
    return Number((val >> 1n) ^ -(val & 1n));
  }

  public readFloat() {
    const val = this.view.getFloat32(this.pos, true);
    this.pos += 4;
    return val;
  }

  public readBitString() {
    const bytes = [];
    while (true) {
      const byte = this.readUInt8();
      bytes.push(byte & 0x7f);
      if (byte < 0x80) {
        break;
      }
    }
    const bitstring = new BitString();
    bitstring.bytes = bytes.reverse();
    return bitstring;
  }

  public readString() {
    const len = this.readUVarint();
    if (len > 0) {
      const val = unpack(this.bytes, this.pos, this.pos + len);
      this.pos += len;
      return val;
    }
    return "";
  }

  public remaining() {
    return this.view.byteLength - this.pos;
  }
}
