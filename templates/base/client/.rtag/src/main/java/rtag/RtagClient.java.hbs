package rtag;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.ByteBuffer;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;
import java.util.function.Consumer;

import com.auth0.jwt.JWT;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.squareup.okhttp.MediaType;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import com.squareup.okhttp.RequestBody;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import org.msgpack.jackson.dataformat.MessagePackFactory;

import lombok.Setter;
{{#each methods}}
import rtag.Types.{{makeRequestName @key}};
{{/each}}
import rtag.Types.{{userState}};
import rtag.Types.CreateStateResponse;
import rtag.Types.LoginResponse;
import rtag.Types.Message;
import rtag.Types.ResponseMessage;
import rtag.Types.Result;
import rtag.Types.ResultCallback;
import rtag.Types.StateMessage;
import rtag.Types.UserData;

public class RtagClient {

    private static final ExecutorService ES = Executors.newSingleThreadExecutor();
    private static final OkHttpClient CLIENT = new OkHttpClient();
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
    private static final ObjectMapper JSON_MAPPER = new ObjectMapper();
    private static final ObjectMapper MSGPACK_MAPPER = new ObjectMapper(new MessagePackFactory());

    private final Map<String, ResultCallback> callbacks = new HashMap<>();
    private final Random rng = new Random();

    @Setter
    private WebSocketClient socket;

    private RtagClient() {
    }

    public static UserData getUserFromToken(String token) throws IOException {
        byte[] data = Base64.getDecoder().decode(JWT.decode(token).getPayload());
        return UserData.builder().value(JSON_MAPPER.readValue(data, UserData.Base.class)).build();
    }
{{#each auth}}
{{#if (eq @key "anonymous")}}

    public static String loginAnonymous(String origin) throws IOException {
        return httpPost(String.format("%s/login/anonymous", origin), "{}", Optional.empty(), LoginResponse.class)
                .getToken();
    }
{{else if (eq @key "google")}}

    public static String loginGoogle(String idToken, String origin) throws IOException {
        return httpPost(String.format("%s/login/google", origin), String.format("{ idToken: %s }", idToken),
                Optional.empty(), LoginResponse.class).getToken();
    }
{{/if}}
{{/each}}

    public static String createState(String origin, String token, ICreateGameRequest request) throws IOException {
        return httpPost(String.format("%s/new", origin), JSON_MAPPER.writeValueAsString(request), Optional.of(token),
                CreateStateResponse.class).getStateId();
    }

    public static RtagClient connect(String host, String token, String stateId, Consumer<{{userState}}> onStateChange)
            throws URISyntaxException {
        RtagClient client = new RtagClient();
        WebSocketClient socket = new WebSocketClient(new URI(String.format("ws://%s/%s", host, stateId))) {

            @Override
            public void onOpen(ServerHandshake handshakedata) {
                this.send(token);
            }

            @Override
            public void onMessage(String message) throws IllegalArgumentException {
                throw new IllegalArgumentException(
                        "String messages are not allowed. Message must be of type ByteBuffer");
            }

            @Override
            public void onMessage(ByteBuffer message) {
                try {
                    byte[] data = message.array();
                    Message msg = MSGPACK_MAPPER.readValue(data, Message.class);
                    if (msg.getType().equals("response")) {
                        ResponseMessage responseMsg = MSGPACK_MAPPER.readValue(data, ResponseMessage.class);
                        ResultCallback resultCallback = client.callbacks.get(responseMsg.getMsgId());
                        resultCallback.getCb().setResult(responseMsg.getResult());
                        ES.execute(resultCallback.getFuture());
                        client.callbacks.remove(responseMsg.getMsgId());
                    } else if (msg.getType().equals("state")) {
                        StateMessage stateMsg = MSGPACK_MAPPER.readValue(data, StateMessage.class);
                        onStateChange.accept(stateMsg.getState());
                    } else {
                        throw new Exception(String.format("Unknown message type: %s", msg.getType()));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            @Override
            public void onClose(int code, String reason, boolean remote) {
                System.out.println("connection closed");
            }

            @Override
            public void onError(Exception ex) {
                ex.printStackTrace();
            }

        };
        socket.connect();
        client.setSocket(socket);
        return client;
    }
    {{#each methods}}

    public Result {{@key}}({{makeRequestName @key}} request)
            throws InterruptedException, ExecutionException, JsonProcessingException {
        String msgId = Integer.toString(rng.nextInt(Integer.MAX_VALUE), 36);
        ResultCallback.ResultCallable cb = new ResultCallback.ResultCallable();
        FutureTask<Result> future = new FutureTask<>(cb);
        this.callbacks.put(msgId, ResultCallback.builder().future(future).cb(cb).build());
        ObjectNode obj = MSGPACK_MAPPER.createObjectNode();
        obj.put("method", "{{@key}}");
        obj.put("msgId", msgId);
        obj.set("args", MSGPACK_MAPPER.convertValue(request, JsonNode.class));
        this.socket.send(MSGPACK_MAPPER.writeValueAsBytes(obj));
        return this.callbacks.get(msgId).get();
    }
    {{/each}}

    public void disconnect() {
        this.socket.close();
    }

    private static <T> T httpPost(String url, String body, Optional<String> token, Class<T> responseType)
            throws IOException {
        Request.Builder request = new Request.Builder().url(url).post(RequestBody.create(JSON, body));
        token.ifPresent(t -> request.header("Authorization", "Bearer " + t));
        String response = CLIENT.newCall(request.build()).execute().body().string();
        return JSON_MAPPER.readValue(response, responseType);
    }
}
