package rtag;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.ByteBuffer;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

import com.auth0.jwt.JWT;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.squareup.okhttp.MediaType;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import com.squareup.okhttp.RequestBody;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import org.msgpack.jackson.dataformat.MessagePackFactory;

import lombok.Setter;

{{#each methods}}
import rtag.Types.{{makeRequestName @key}};
{{/each}}
import rtag.Types.Result;
import rtag.Types.ResultCallback;
import rtag.Types.StateChangeRunnable;
import rtag.Types.Message;
import rtag.Types.ResponseMessage;
import rtag.Types.StateMessage;
import rtag.Types.LoginResponse;
import rtag.Types.CreateStateResponse;
import rtag.Types.UserData;

public class RtagClient {
    private Map<String, ResultCallback> callbacks = new HashMap<String, ResultCallback>();
    private static ExecutorService es = Executors.newSingleThreadExecutor();
    private static OkHttpClient client = new OkHttpClient();
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
    private static ObjectMapper jsonMapper = new ObjectMapper();
    private static ObjectMapper msgPackMapper = new ObjectMapper(new MessagePackFactory());

    @Setter
    private WebSocketClient socket;

    private RtagClient() {
    }

    public static UserData getUserFromToken(String token) throws IOException {
        JWT.decode(token);
        byte[] data = Base64.getDecoder().decode(JWT.decode(token).getPayload());
        return UserData.builder().value(jsonMapper.readValue(data, UserData.Base.class)).build();
    }

    {{#each auth}}
    {{#if (eq @key "anonymous")}}
    public static String loginAnonymous(String origin) throws IOException {
        Request request = new Request.Builder().url(String.format("%s/login/anonymous", origin))
                .post(RequestBody.create(JSON, "{}")).build();
        String response = client.newCall(request).execute().body().string();
        return jsonMapper.readValue(response, LoginResponse.class).getToken();
    }

    {{else if (eq @key "google")}}
    public static String loginGoogle(String origin) throws IOException {
        Request request = new Request.Builder().url(String.format("%s/login/google", origin))
                .post(RequestBody.create(JSON, "{}")).build();
        String response = client.newCall(request).execute().body().string();
        return jsonMapper.readValue(response, LoginResponse.class).getToken();
    }

    {{/if}}
    {{/each}}

    public static String createState(String origin, String token, ICreateGameRequest request) throws IOException {
        String response = client.newCall(new Request.Builder().url(String.format("%s/new", origin))
                .post(RequestBody.create(JSON, "{}")).header("Authorization", "Bearer " + token).build()).execute()
                .body().string();
        return jsonMapper.readValue(response, CreateStateResponse.class).getStateId();
    }

    public static RtagClient connect(String host, String token, String stateId, StateChangeRunnable onStateChange)
            throws URISyntaxException {
        RtagClient client = new RtagClient();
        WebSocketClient socket = new WebSocketClient(new URI(String.format("ws://%s/%s", host, stateId))) {

            @Override
            public void onOpen(ServerHandshake handshakedata) {
                this.send(token);
            }

            @Override
            public void onMessage(String message) throws IllegalArgumentException {
                throw new IllegalArgumentException("String messages are not allowed. Message must be of type ByteBuffer");
            }

            @Override
            public void onMessage(ByteBuffer message) {
                try {
                    byte[] data = message.array();
                    Message msg = msgPackMapper.readValue(data, Message.class);
                    if (msg.getType().equals("response")) {
                        ResponseMessage responseMsg = msgPackMapper.readValue(data, ResponseMessage.class);
                        ResultCallback resultCallback = client.callbacks.get(responseMsg.getMsgId());
                        resultCallback.getCb().setResult(responseMsg.getResult());
                        es.execute(resultCallback.getFuture());
                        client.callbacks.remove(responseMsg.getMsgId());
                    } else if (msg.getType().equals("state")) {
                        StateMessage stateMsg = msgPackMapper.readValue(data, StateMessage.class);
                        onStateChange.run(stateMsg.getState());
                    } else {
                        throw new Exception(String.format("Unknown message type: %s", msg.getType()));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            @Override
            public void onClose(int code, String reason, boolean remote) {
                System.out.println("connection closed");
            }

            @Override
            public void onError(Exception ex) {
                ex.printStackTrace();
            }

        };
        socket.connect();
        client.setSocket(socket);
        return client;
    }

    {{#each methods}}
    public Result {{@key}}({{makeRequestName @key}} request)
            throws InterruptedException, ExecutionException, JsonProcessingException {
        final String msgId = Integer.toString((int) (Math.random() * 1000000000), 36).substring(2);
        ResultCallback.ResultCallable cb = new ResultCallback.ResultCallable();
        FutureTask<Result> future = new FutureTask<>(cb);
        this.callbacks.put(msgId, ResultCallback.builder().future(future).cb(cb).build());
        ObjectNode obj = msgPackMapper.createObjectNode();
        obj.put("method", "{{@key}}");
        obj.put("msgId", msgId);
        obj.set("args", msgPackMapper.convertValue(request, JsonNode.class));
        this.socket.send(msgPackMapper.writeValueAsBytes(obj));
        return this.callbacks.get(msgId).get();
    }
    {{/each}}

    public void disconnect() {
        this.socket.close();
    }
}
